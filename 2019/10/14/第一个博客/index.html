<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>第一个博客 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="John Doe">
  <meta name="keywords" content>
  <meta name="description" content>
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'hexo-theme-lx-master',
    version: '1.4.5',
    localsearch:{
      "enable": false,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: '-'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "endless-river",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:300|Noto+Serif+SC&amp;display=swap">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
</head>
<body>
<div class="single">
<div id="page">
<div id="lx-aside" style="background-image: url(/images/page-cover.jpg)" data-stellar-background-ratio="0.5">
  <div class="overlay">
  <div class="page-title">
    <div class="avatar"><a href="/"><img src="/images/mn_1.jpg"></a></div>
    <span>2019-10-14</span>
    <h2>第一个博客</h2>
    
    </div>
</div>
</div>
<div id="lx-main-content">
  <div class="lx-post">
    <div class="lx-entry padding">
      <div>
        <p>以下是一些java总结<br>一、面向对象<br>类、对象、变量<br>（1）所有的Java程序都已类class为组织单元；类由属性和方法两部分组成<br>（2）先创建对象，再使用对象<br>（3）成员变量：类中定义，自动定义初始值<br>局部变量：类方法中定义（两变量同名，局部变量有更高的优先级）<br>构造方法<br>构造方法是定义在java类中的一个用来初始化对象的方法，与类同名且没有返回值。<br>public 构造方法名（）{<br>}<br>其中构造方法名与类同名；当没有指定的构造方法时，系统会自动添加无参构造方法<br>Static使用<br>Static修饰的成员属于整个类，被类的所有对象共享。可通过使用类名直接访问静态成员，也可通过对象名<br>Static可以修饰变量、方法和代码块<br>（1）Static使用之静态方法<br>public class Helloworld {<br>public static void print() {<br>System.out.println(“***”);<br>}<br>public static void main(String[] args) {<br>    Helloworld.print();<br>    Helloworld demo = new Helloworld;<br>    demo.print();<br>}<br>}<br>注意：静态方法中可以直接调用同类的静态成员，但不可以直接调用非静态成员；普通成员方法中可以直接访问同类的非静态变量和静态变量；静态方法中不能直接调用非静态成员方法<br>（2）Static使用之静态初始化块<br>静态初始化块在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通成员<br>public class Helloworld {<br>int num1;<br>int num2;<br>static int num3;<br>public Helloworld() {<br>    num1 = 91;<br>    System.out.println(“构造方法为num1赋值”);<br>    num2 = 74;<br>    System.out.println(“初始化块为num2赋值”);<br>    num3 = 83;<br>    System.out.println(“静态初始化块为num3赋值”);<br>}</p>
<p>public static void main(String[] args) {<br>    Helloworld hello = new Helloworld();<br>    System.out.println(hello.num1);<br>    System.out.println(hello.num2);<br>    System.out.println(num3);<br>    Helloworld hello2 = new Helloworld();<br>}<br>}<br>运行结果：静态初始化块为num3赋值<br>初始化块为num2赋值<br>构造方法为num1赋值<br>91<br>74<br>83<br>初始化块为num2赋值<br>构造方法为num1赋值<br>二、java面向对象的特性<br>封装性：将类的某些信息隐藏在内部，通过类的方法来实现操作访问<br>步骤：<br>1 修改属性可见性；<br>2 创建getter\setter方法；<br>3在方法中加入属性控制语句<br>(1)静态内部类:<br>public class SOuter {<br>private int a = 99;<br>static int b = 1;<br>public static class SInner {<br>    int b = 2;</p>
<pre><code>public void test() {
    System.out.println(&quot;访问外部类b&quot; + SOuter.b);
    System.out.println(&quot;访问内部类b&quot; + b);
}</code></pre><p>}</p>
<p>public static void main(String[] args) {</p>
<pre><code>//三行表示
SInner sInner;
sInner = new SInner();
sInner.test();

//两行表示
SInner si = new SInner();
si.test();

//一行表示
new SInner().test();</code></pre><p>}<br>}<br>(2)成员内部类：访问外部类时使用this指针<br>（3）方法内部类：只能在该方法中使用，且不能使用访问控制符和Static修饰符<br>2. 继承性<br>（1）一般形式：class 子类 extends 父类<br>（2）方法重写：子类对继承的父类方法不满意可以重写，调用时优先调用子类方法<br>（3）继承的初始化顺序：先初始化父类，再到子类；先执行初始化对象中属性，再执行狗在方法中的初始化<br>（4）父类对象–属性初始化–构造方法–子类对象–属性初始化–构造方法<br>（5）注意：如果子类构造方法中没有显示调用父类的构造方法，默认调用父类无参构造方法，若此父类没用无参的构造方法，则编译出错<br>多态性<br>引用多态：父类的引用可以指向本类的对象，也可指向子类的对象<br>方法多态：创建本类对象时，调用的方法为本类方法；创建子类对象时，调用的方法为子类的重写的方法或者继承的方法<br>（1）抽象类<br>用关键字abstract修饰：抽象类只用声明不需要实现；包含抽象方法的类为抽象类；抽象类不能直接创建，可以定义引用变量。<br>public abstract class Telphone{<br>public abstract void call(); //抽象方法没有方法体，以分号结束<br>}<br>（2）接口（一种特殊的类，有全局变量和公共抽象方法组成）<br>[修饰符] class 类名 extends 父类implemrnts 接口1,2……<br>{类体部分<br>}<br>注：接口经常与匿名内部类配合使用<br>public interface Iplay{<br>public void phone();<br>}<br>public class People implements Iplay{<br>public static void main(String[] args){<br>People test=new People();<br>test.phone();<br>}<br>public void phone(){<br>System.out.println(“手机可以玩游戏”);<br>}<br>}<br>1.String、StringBuilder、StringBuffer的区别是什么，String为什么是不可变的？<br>不可变性<br>String类的底层源码中，通过final关键字修饰字符串数组，private final char value[]，所以是不可变的。StringBuffer和StringBuilder类是集成自 AbstractStringBuilder 类， AbstractStringBuilder 类中的变量没有用final关键字修饰，所以是可变的。<br>线程安全性<br>String是不可变的，是常量，所以是线程安全的。StringBuilder和StringBuffer都继承自AbstractStringBuilder 类，StringBuffer对方法加了同步锁，所以是线程安全的，而StringBuilder没有加同步锁，所以是线程不安全的。<br>性能<br>对String类型进行改变是都会new一个新的string对象，并指向新的对象；<br>StringBuffer直接通过改变自身变量的值，StringBuilder相对能提升性能，但有线程不安全的情况。<br>2.== 与 equals<br>==用来判断两个对象是否相等，基础数据类型比较的是值是否相等。<br>没有重写对象的equals方法时，也是用来比较两个对象是否相等，重写equals方法可以比较内容相等，返回true<br>3.try/catch/finally中finally是否一定执行<br>在以下4种特殊情况下，finally块不会被执行:<br>在finally语句块中发生了异常。<br>在前面的代码中用了System.exit()退出程序。<br>程序所在的线程死亡。<br>关闭CPU。<br>4.接口和抽象类的区别？<br>1.抽象类中可以实现方法，抽象接口不能实现方法（jdk1.8以后可以实现方法）；<br>2.接口中的变量默认是final类型，而抽象类不是；<br>3.类只能继承一个抽象类，而接口可以实现多个；<br>4.类继承接口需要实现所有方法，抽象类不需要；<br>5.接口不能用new实例化，可以声明。必须引用一个实现该接口的对象抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。<br>5.Arraylist 与 LinkedList 异同<br>安全性<br>ArrayList与LinkedList都是线程不安全的。<br>数据结构实现<br>ArryayList是基于Object数组，而LinkedList是基于双向循环链表（JDK1.6之前为循环链表，之后取消了循环）<br>插入删除的影响<br>ArrayList采用数组存储，插入删除受元素位置的影响；<br>LinkedList采用链表存储，插入删除不收元素位置影响；<br>访问元素<br>LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。<br>实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,未实现RandomAccess接口的list， 优先选择iterator遍历(foreach遍历底层也是通过iterator实现的)，大size的数据，千万不要使用普通for循环<br>6.ArrayList 与 Vector 区别<br>Vector中所有方法都是同步的，在多线程操作中，同步操作会耗费时间，而ArrayList是不需要同步的，在不需要考虑线程安全时可以使用。<br>7.HashMap的底层实现<br>待补充完善<br>8.HashSet 和 HashMap 区别<br>HashMap实现Map接口，用来存储键值对，调用put方法添加元素，使用Key计算Hashcode，而HashSet实现Set接口，用来存储对象，调用add方法添加对象，使用对象计算hashcode，根据equals方法判断对象相等，执行效率的话，HashMap优与HashSet。<br>9.ConcurrentHashMap 和 Hashtable 的区别<br>ConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。ConcurrentHashMap使用的是分段锁，HashTable使用的是同一把锁，因而在多线程并发中效率很低。<br>10.多线程实现方式<br>1.继承Thread类，2.实现Runnable接口，3.基于线程池实现</p>

      </div>
    </div>
  </div>
</div>
<div class="lx-navigation">
	<div class="lx-cover prev lx-cover-sm" style="background-image: url(/images/footer_1.jpg)">
		<div class="overlay"></div>
		<a class="copy" href="#">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Next</span>
						<h3>没有更新的文章</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
        <div class="lx-cover next lx-cover-sm" style="background-image: url(/images/footer_2.jpg)">
		<div class="overlay"></div>
		<a class="copy" href="/2019/10/14/post-title-with-whitespace/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Prev</span>
						<h3>post title with whitespace</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
</div>
</div>

<footer>
  <div>
  Copyright &copy; 2019.<a href="/">Hexo</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.blleng.cn" target="_blank">Lx</a><br>
  </div>
</footer>
</div>

<button class="menu-trigger"></button>
<div class="menu">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/mn_1.jpg" alt="John Doe"></a>
          </div>
        </div>
        <div class="row for-name">
          <p>John Doe</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>首页</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>归档</a></li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>页面</span>
        <ul>
          <li><a href="/guestbook">留言</a></li>
        <li><a href="/about">关于</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>友链</span>
        <ul>
          <li> <a href="https://lx.blleng.cn" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="/js/jquery.easing.min.js"></script>
<script src="/js/jquery.waypoints.min.js"></script>
<script src="/js/jquery.stellar.min.js"></script>
<script src="/js/main.js"></script>


</body>
</html>
